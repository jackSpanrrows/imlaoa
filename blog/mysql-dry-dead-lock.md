<!--
author: 老A在Coding
date: 2021-1-3
title: MySQL事务浅谈4之死锁
tags: MySQL
category: MySQL,MySQL死锁
status: publish
summary: MySQL 死锁
-->

###```死锁```


```死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。```

``` 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。```  

```例如：```
设想下面两个事务同时处理 ```StockPrice``` 表：

```事务1：```  

![avatar](http://static.imlaoa.com/imlaoa/dead_lock1.png)
```
事务2：
```
![avatar](http://static.imlaoa.com/imlaoa/dead_lock2.png)



如果凑巧，两个事务都执行了第一条 ```UPDATE``` 语句，更新了一行数据，同时也锁定了改行数据，接着每个事务都尝试去执行

第二条 ```UPDATE``` 语句，缺发现该行已经被对方锁定，然后两个事务都在等待对方释放锁，同时又持有对方需要的锁，则陷入死

循环。除非有外部因素介入才可能解除```死锁```。

为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如 ```InnoDB``` 存储引擎，越能检测到死锁

的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。

还有一种解决方式，就是当查询的时候达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。

```InnoDB``` 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。


```如下图显示进程正在执行中：```


![avatar](http://static.imlaoa.com/imlaoa/dead_lock.png)

锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：

有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。

```死锁```发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时

必须考虑如何处理```死锁```。大多数情况下只需要重新执行因死锁回滚的事务即可。    
   

上一篇 [MySQL事务浅谈3之隔离级别](http://www.imlaoa.com/blog/mysql-dry-isolation.html)
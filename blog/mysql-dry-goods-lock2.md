<!--
author: 老A在Coding
date: 2020-12-6
title: [理论干货]锁策略
tags: MySQL,干货,锁策略
category: MySQL,锁策略
status: publish
summary: MySQL锁策略
-->

     
 今天我跟大家说说MySQL中最重要的两种锁策略。

 1、表锁

   表锁（table lock）是 MySQL 中最基本的锁策略，并且是开销最小的策略。表锁非常类似于邮箱加锁机制：
它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其它用户对该表的所有读
写操作。只有没有写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的。
在特定的场景中，表锁也可能有良好的性能。例如：READ LOCAL 表锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面（写锁可以插入到锁队列中读锁的前面，反之则不能插入到写锁的前面）。
       
    尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表锁来实现不同的目的。
    
    例如，服务器会为诸如 ALTER TABLE 之类的语句使用表锁，而忽略存储引擎的锁机制。
     
     
 2、行级锁（row lock）
 
   行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在 InnoDB 和 XtraDB，以及其它一些存
   
   储引擎中实现了行级锁。行级锁只有在存储引擎层实现，而 MySQL 服务器层（可以参考前面的文章 MySQL 逻辑架构一文）
   
   没有实现。服务器层完全不了解存储引擎中的锁实现。我们将会陆续给大家介绍存储引擎以自己的方式来显
   
   现锁机制。
   
 
上一篇 [[理论干货]MySQL锁粒度](http://www.imlaoa.com/blog/mysql-dry-goods-lock1.html)
下一篇 [[理论干货]MySQL事务浅谈之事务正解](http://www.imlaoa.com/blog/mysql-dry-affairs.html)
